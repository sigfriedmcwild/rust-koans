From a44ea57f985fd7af9e5cd3b66da5214fdf8ad917 Mon Sep 17 00:00:00 2001
From: Luca Beltrami <sigfriedmcwild@gmail.com>
Date: Sun, 7 Oct 2018 19:01:04 -0700
Subject: [PATCH] solutions

---
 .vscode/tasks.json     | 22 ++++++++++++++++
 koans.code-workspace   |  8 ++++++
 src/koans/addition.rs  |  2 +-
 src/koans/array.rs     | 31 +++++++++++++----------
 src/koans/boolean.rs   |  8 +++---
 src/koans/hash_map.rs  | 23 +++++++++--------
 src/koans/integer.rs   | 16 ++++++------
 src/koans/ownership.rs | 26 +++++++++----------
 src/koans/string.rs    | 24 +++++++++---------
 src/koans/struct.rs    | 16 ++++++------
 src/koans/the_truth.rs |  2 +-
 src/koans/traits.rs    | 24 ++++++++++++++----
 src/koans/vec.rs       | 57 ++++++++++++++++++++++--------------------
 13 files changed, 157 insertions(+), 102 deletions(-)
 create mode 100644 .vscode/tasks.json
 create mode 100644 koans.code-workspace

diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 0000000..8818754
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,22 @@
+{
+    // See https://go.microsoft.com/fwlink/?LinkId=733558
+    // for the documentation about the tasks.json format
+    "version": "2.0.0",
+    "tasks": [
+        {
+            "type": "cargo",
+            "label": "cargo run",
+            "command": "cargo",
+            "args": [
+                "run"
+            ],
+            "problemMatcher": [
+                "$rustc"
+            ],
+            "group": {
+                "kind": "build",
+                "isDefault": true
+            }
+        }
+    ]
+}
diff --git a/koans.code-workspace b/koans.code-workspace
new file mode 100644
index 0000000..876a149
--- /dev/null
+++ b/koans.code-workspace
@@ -0,0 +1,8 @@
+{
+	"folders": [
+		{
+			"path": "."
+		}
+	],
+	"settings": {}
+}
\ No newline at end of file
diff --git a/src/koans/addition.rs b/src/koans/addition.rs
index 61a25f8..2f9720f 100644
--- a/src/koans/addition.rs
+++ b/src/koans/addition.rs
@@ -1,4 +1,4 @@
 #[test]
 fn addition() {
-    assert_eq!(1 + __, 2)
+    assert_eq!(1 + 1, 2)
 }
diff --git a/src/koans/array.rs b/src/koans/array.rs
index 6a53709..0b062fe 100644
--- a/src/koans/array.rs
+++ b/src/koans/array.rs
@@ -3,7 +3,7 @@
 #[test]
 fn array_index() {
     let arr: [i32; 5] = [1, 2, 3, 4, 5];
-    assert!(arr[__] == 1);
+    assert!(arr[0] == 1);
 }
 
 // A new fixed size array can be created by declaring the type of its elements
@@ -11,7 +11,7 @@ fn array_index() {
 // [i32; 0] = []
 #[test]
 fn array_empty() {
-    let arr: __;
+    let arr: [i32; 0] = [];
     assert!(arr.len() == 0);
 }
 
@@ -20,9 +20,10 @@ fn array_empty() {
 // that error in this example.
 #[test]
 #[should_panic]
+#[allow(const_err)] // TODO push fix
 fn out_of_index() {
     let arr: [&'static str; 5] = ["rust", "is", "mostly", "for", "nerds"];
-    arr[__];
+    arr[5];
 }
 
 // Elements can be replaced in an array at a certain index.
@@ -30,7 +31,7 @@ fn out_of_index() {
 #[test]
 fn insert_at_index() {
     let mut arr: [u8; 5] = [0, 1, 2, 3, 4];
-    __ = 0;
+    arr[4] = 0;
     assert!(arr == [0, 1, 2, 3, 0]);
 }
 
@@ -39,16 +40,16 @@ fn insert_at_index() {
 fn array_iteration() {
     let arr: [u8; 3] = [3, 2, 1];
     let mut iterator = arr.iter();
-    assert!(iterator.next().unwrap() == &__);
-    assert!(iterator.next().unwrap() == &__);
-    assert!(iterator.next().unwrap() == &__);
+    assert!(iterator.next().unwrap() == &3);
+    assert!(iterator.next().unwrap() == &2);
+    assert!(iterator.next().unwrap() == &1);
 }
 
 // Arrays can also be mutated during iteration
 #[test]
 fn array_map() {
     let arr: [u32; 4] = [2, 5, 7, 4];
-    let mut iterator = arr.iter().map(__);
+    let mut iterator = arr.iter().map(|x| x * 2);
     assert!(iterator.next() == Some(4));
     assert!(iterator.next() == Some(10));
     assert!(iterator.next() == Some(14));
@@ -59,7 +60,7 @@ fn array_map() {
 #[test]
 fn array_filter() {
     let arr: [u16; 5] = [1, 2, 3, 4, 5];
-    let mut iterator = arr.iter().filter(__);
+    let mut iterator = arr.iter().filter(|&x| x % 2 == 0);
     assert!(iterator.next().unwrap() == &2);
     assert!(iterator.next().unwrap() == &4);
     assert!(iterator.next().is_none());
@@ -69,7 +70,7 @@ fn array_filter() {
 #[test]
 fn array_filter_map() {
     let arr: [u8; 5] = [2, 1, 2, 1, 2];
-    let mut iterator = arr.iter().filter_map(|&x| if x == 1 { Some(__) } else { None });
+    let mut iterator = arr.iter().filter_map(|&x| if x == 1 { Some(3) } else { None });
     assert!(iterator.next() == Some(3));
     assert!(iterator.next() == Some(3));
     assert!(iterator.next().is_none());
@@ -85,8 +86,8 @@ fn complex_array_filter_map() {
         } else {
             None
         });
-    assert!(iterator.next().unwrap() == __);
-    assert!(iterator.next().unwrap() == __);
+    assert!(iterator.next().unwrap() == 2);
+    assert!(iterator.next().unwrap() == 4);
     assert!(iterator.next().is_none());
 }
 
@@ -97,6 +98,7 @@ fn for_loops() {
     let mut y: u64 = 1;
     for x in &arr {
         assert!(*x == y);
+        y += 1;
     }
 }
 
@@ -106,8 +108,11 @@ fn for_loops_two() {
     let words: [&'static str; 3] = ["I", "love", "Rust"];
     let mut sentence: String = String::new();
     for word in words.iter() {
-        __
+        sentence += word;
+        sentence += " ";
     }
+    let new_len = sentence.len() - 1;
+    sentence.truncate(new_len);
     println!("{:?}", sentence);
     assert!(sentence == "I love Rust".to_string());
 }
diff --git a/src/koans/boolean.rs b/src/koans/boolean.rs
index 9abf491..e90a4a2 100644
--- a/src/koans/boolean.rs
+++ b/src/koans/boolean.rs
@@ -2,25 +2,25 @@
 // Two equal values will return true when compared with the == operator
 #[test]
 fn truth() {
-    assert!(true __ true);
+    assert!(true __ true); // TODO push fix
 }
 
 // Likewise, two unequal values will return false when compared with ==
 // The != operator can be used to return true for an inequality
 #[test]
 fn falsehood() {
-    assert!(false __ true);
+    assert!(false != true);
 }
 
 // Strings can also be compared and will return a boolean
 #[test]
 fn string_equality() {
-    assert!("Stuff" == __);
+    assert!("Stuff" == "Stuff");
 }
 
 // Integers can be compared as long as they are of the same type
 #[test]
 fn int_equality() {
     let num: i8 = 5;
-    assert!(num == __);
+    assert!(num == 5);
 }
diff --git a/src/koans/hash_map.rs b/src/koans/hash_map.rs
index 24cbbfb..b40a60e 100644
--- a/src/koans/hash_map.rs
+++ b/src/koans/hash_map.rs
@@ -6,7 +6,7 @@ fn simple_hash_map() {
     let mut hm = HashMap::new();
     hm.insert("first", 1);
     hm.insert("second", 2);
-    assert_eq!(hm.len(), __);
+    assert_eq!(hm.len(), 2);
 }
 
 // You can access the values of a HashMap using the correlating key
@@ -15,14 +15,14 @@ fn hash_map_get() {
     let mut map = HashMap::new();
     map.insert("Rust", "https://www.rust-lang.org/");
     map.insert("Ruby", "https://www.ruby-lang.org/");
-    assert_eq!(map.get(__), Some(&"https://www.rust-lang.org/"));
+    assert_eq!(map.get("Rust"), Some(&"https://www.rust-lang.org/"));
 }
 
 // Attempting to retrieve a key that doesn't exist will return a None option
 #[test]
 fn its_not_there() {
     let map: HashMap<&str, &str> = HashMap::new();
-    assert_eq!(map.get("Rust"), __);
+    assert_eq!(map.get("Rust"), None);
 }
 
 // Instead of the get() method, values can also be retrieved using []
@@ -32,7 +32,7 @@ fn brackets() {
     map.insert("iPhone", "Apple");
     map.insert("Galaxy", "Samsung");
     assert_eq!(map[&"iPhone"], "Apple");
-    assert_eq!(__, "Samsung");
+    assert_eq!(map[&"Galaxy"], "Samsung");
 }
 
 // Keys in HashMaps will always be unique
@@ -41,13 +41,15 @@ fn duplicate_key() {
     let mut hm = HashMap::new();
     hm.insert("Harry Potter", "Sorcerer's Stone");
     hm.insert("Harry Potter", "Goblet of Fire");
-    assert_eq!(hm[&"Harry Potter"], "Sorcerer's Stone");
+    assert_eq!(hm[&"Harry Potter"], "Goblet of Fire");
 }
 
 // A HashMap's values, however, do not have this constraint
 #[test]
 fn duplicate_values() {
     let mut hm = HashMap::new();
+    hm.insert("Sorcerer's Stone", "Harry Potter");
+    hm.insert("Goblet of Fire", "Harry Potter");
     assert_eq!(hm[&"Sorcerer's Stone"], hm[&"Goblet of Fire"]);
 }
 
@@ -58,7 +60,7 @@ fn just_the_keys() {
     map.insert("Episode IV", "A New Hope");
     map.insert("Episode V", "Empire Strikes Back");
     map.insert("Episode VI", "Return of the Jedi");
-    let episodes = vec![__];
+    let episodes = vec!["Episode IV", "Episode V", "Episode VI"];
     for episode in map.keys() {
         assert!(episodes.contains(episode));
     }
@@ -73,7 +75,7 @@ fn just_the_values() {
     map.insert("Red", "Fish");
     map.insert("Blue", "Fish");
     for num in map.values() {
-        assert_eq!(num, __);
+        assert_eq!(num, &"Fish");
     }
 }
 
@@ -85,7 +87,7 @@ fn iterating() {
     map.insert(2, 4);
     map.insert(3, 9);
     for (key, value) in map.iter() {
-        assert_eq!(&(__), value);
+        assert_eq!(&(map[key]), value);
     }
 }
 
@@ -96,8 +98,8 @@ fn iterating_2() {
     map.insert(1, 1);
     map.insert(2, 4);
     map.insert(3, 9);
-    for __ in &map {
-        assert_eq!(__, value);
+    for (key, value) in &map {
+        assert_eq!(&map[key], value);
     }
 }
 
@@ -107,5 +109,6 @@ fn clearing() {
     let mut map = HashMap::new();
     map.insert("chairs", 30);
     map.insert("tables", 8);
+    map.clear();
     assert_eq!(map.get("chairs"), None);
 }
diff --git a/src/koans/integer.rs b/src/koans/integer.rs
index 82893d3..eaa4d9c 100644
--- a/src/koans/integer.rs
+++ b/src/koans/integer.rs
@@ -1,7 +1,7 @@
 // As the name implies, unsigned integers (u8, u16, u32, u64) cannot be negative
 #[test]
 fn unsigned_ints() {
-    assert!(u8::min_value() == __);
+    assert!(u8::min_value() == 0);
 }
 
 // Unsigned integers can be reduced only as far as their minimum value of 0
@@ -9,13 +9,13 @@ fn unsigned_ints() {
 fn sub_unsigned_int() {
     let mut num: u8 = 10;
     num -= 10;
-    assert!(num __ u8::min_value());
+    assert!(num == u8::min_value());
 }
 
 // Signed integers(i8, i16, i32, i64), on the other hand, can be negative
 #[test]
 fn signed_ints() {
-    assert!(i8::min_value() __ 0);
+    assert!(i8::min_value() < 0);
 }
 
 // Signed integers can be reduced below zero, as far as their minimum value.
@@ -24,7 +24,7 @@ fn signed_ints() {
 #[test]
 fn sub_signed_int() {
     let mut num: i8 = 0;
-    let negative: i8 = __;
+    let negative: i8 = i8::min_value();
     num += negative;
     assert!(num == i8::min_value());
 }
@@ -34,15 +34,15 @@ fn sub_signed_int() {
 fn add_numbers() {
     let mut sig: i8 = 0;
     let mut unsig: u8 = 0;
-    sig += __;
-    unsig += __;
+    sig += i8::max_value();
+    unsig += u8::max_value();
     assert!(sig == i8::max_value() && unsig == u8::max_value());
 }
 
 // Like any variable in Rust, integers are immutable unless declared otherwise
 #[test]
 fn mutating_ints() {
-    let num: i8 = 1;
+    let mut num: i8 = 1;
     num += 2;
     assert!(num == 3);
 }
@@ -51,7 +51,7 @@ fn mutating_ints() {
 #[test]
 fn referencing_values() {
     let num: i8 = 1;
-    __ = num;
+    let mut mut_num = num;
     mut_num += 1;
     assert!(num != mut_num);
 }
diff --git a/src/koans/ownership.rs b/src/koans/ownership.rs
index 3285c96..b4ada0e 100644
--- a/src/koans/ownership.rs
+++ b/src/koans/ownership.rs
@@ -10,7 +10,7 @@ fn owning_a_value() {
         let x = 10;
     }
     assign_a_value();
-    assert_eq!(x, 10);
+    //assert_eq!(x, 10);
 }
 
 // When a variable goes out of scope, it is cleaned up by Rust and its memory is deallocated.
@@ -22,7 +22,7 @@ fn owning_a_value_2() {
         let y = &x;
     }
     assign_a_value();
-    assert_eq!(y, &10);
+    //assert_eq!(y, &10);
 }
 
 // Another example of a variables ownership ending is the concept of "moving" the value.
@@ -31,7 +31,7 @@ fn owning_a_value_2() {
 fn moving_a_value() {
     let name = String::from("Chris");
     let first_name = name;
-    assert_eq!(name, "Chris".to_string());
+    assert_eq!(first_name, "Chris".to_string());
 }
 
 // Some confusion can arise with moving values, because certain data types aren't moved.
@@ -41,7 +41,7 @@ fn moving_a_value() {
 fn copying_a_value() {
     let name = "Chris";
     let first_name = name;
-    assert_eq!(name, __);
+    assert_eq!(name, "Chris");
 }
 
 // The same will happen with integer types like i32. These types contain no pointers to other data.
@@ -50,7 +50,7 @@ fn copying_a_value() {
 fn copying_a_value_2() {
     let num: i32 = 12;
     let x = num;
-    assert_eq!(x, __);
+    assert_eq!(x, 12);
 }
 
 // Now that we've explored the difference between what types get moved and what types get copied,
@@ -60,7 +60,7 @@ fn copying_a_value_2() {
 fn rebinding_a_vec() {
     let list = vec!["Rust", "Go", "C++"];
     let languages = list;
-    assert_eq!(list[0], "Rust");
+    assert_eq!(languages[0], "Rust");
 }
 
 // Now that you've learned a bit about ownership in Rust, it's time to look at borrowing.
@@ -71,8 +71,8 @@ fn rebinding_a_vec() {
 fn simple_borrowing() {
     let name = String::from("Chris");
     let first_name = &name;
-    assert_eq!(__, "Chris".to_string());
-    assert_eq!(__, &"Chris".to_string());
+    assert_eq!(name, "Chris".to_string());
+    assert_eq!(first_name, &"Chris".to_string());
 }
 // Unlike our earlier example, name has not been deallocated,
 // because first_name has created a reference to it.
@@ -82,7 +82,7 @@ fn simple_borrowing() {
 fn mutable_borrowing() {
     let mut count = 10;
     {
-        let new_count = &count;
+        let new_count = &mut count;
         *new_count += 1;
         assert_eq!(new_count, &11);
     }
@@ -94,12 +94,12 @@ fn mutable_borrowing() {
 fn borrowing_through_functions() {
     let mut vector = vec![1, 2, 3];
 
-    fn insert_next_number(v: Vec<i32>) {
+    fn insert_next_number(v: &mut Vec<i32>) {
         let x = v.last().unwrap() + 1;
         v.push(x);
     }
 
-    insert_next_number(vector);
+    insert_next_number(&mut vector);
 
     assert_eq!(vector, vec![1, 2, 3, 4]);
 }
@@ -119,7 +119,7 @@ fn implicit_lifetime() {
     let sum = add(x, y);
 
     assert_eq!(sum, 20);
-    assert_eq!(a, 10);
+    //assert_eq!(a, 10);
 }
 
 // Let's look at a similar function, but with references passed as arguments instead
@@ -137,6 +137,6 @@ fn explicit_lifetime() {
 
     let max = max(&x, &y);
 
-    assert_eq!(max, 20);
+    assert_eq!(*max, 20);
 }
 // Here we're saying that the i32 we return will have a lifetime equal to that of the function max
diff --git a/src/koans/string.rs b/src/koans/string.rs
index f07f47e..c379a38 100644
--- a/src/koans/string.rs
+++ b/src/koans/string.rs
@@ -4,7 +4,7 @@
 #[test]
 fn string_literals() {
     let string_slice = "Hello World";
-    assert!(string_slice == __);
+    assert!(string_slice == "Hello World");
 }
 
 // A String is a heap-allocated string in Rust.
@@ -14,7 +14,7 @@ fn growable_strings() {
     let mut string = String::new();
     string.push_str("Hello");
     string.push_str(" World");
-    assert!(string == __);
+    assert!(string == "Hello World");
 }
 
 // A string slice can be converted to a String using to_string
@@ -24,14 +24,14 @@ fn growable_strings() {
 fn growable_string_literals() {
     let mut mutable = "Foo".to_string();
     mutable.push_str("Bar");
-    assert!(mutable == __);
+    assert!(mutable == "FooBar");
 }
 
 // A String can be coerced into a slice by prefacing it with a &
 #[test]
 fn string_to_slice() {
     let string = "Can't stop me now".to_string();
-    let slice: &str = __;
+    let slice: &str = &string;
     assert!(slice == "Can't stop me now");
 }
 
@@ -41,7 +41,7 @@ fn strings_with_strs() {
     let hello = "Hello ".to_string();
     let world = "World";
 
-    assert!(hello + world == __);
+    assert!(hello + world == "Hello World");
 }
 
 // But two Strings require a & to coorce the second String
@@ -50,7 +50,7 @@ fn strings_with_strings() {
     let hello = "Hello ".to_string();
     let world = "World!".to_string();
 
-    let hello_world = __ + __;
+    let hello_world = hello + &world;
     assert!(hello_world == "Hello World!")
 }
 
@@ -60,14 +60,14 @@ fn strings_with_strings() {
 #[test]
 fn using_chars() {
     let string = "Anybody hungry?";
-    assert!(string.chars().nth(2) == __.chars().nth(0));
+    assert!(string.chars().nth(2) == "y".chars().nth(0));
 }
 
 // You can get a slice of a string using slicing syntax
 #[test]
 fn slicing_the_string() {
     let string = "Boom";
-    assert!(&string[0..2] == __);
+    assert!(&string[0..2] == "Bo");
 }
 
 // However these are BYTE offsets not character offsets -
@@ -84,7 +84,7 @@ fn slicing_the_byte() {
 fn truncate_string() {
     let mut string = String::from("Hello World!");
     string.truncate(5);
-    assert!(string == __);
+    assert!(string == "Hello");
 }
 
 // You can pop Strings
@@ -92,7 +92,7 @@ fn truncate_string() {
 fn pop_string() {
     let mut string = String::from("Hello");
     string.pop();
-    assert!(string == __);
+    assert!(string == "Hell");
 }
 
 // You can insert and remove from a String (at byte position)
@@ -100,8 +100,8 @@ fn pop_string() {
 fn insert_and_remove_into_string() {
     let mut string = String::from("Hello");
     string.insert(2, 'e');
-    assert!(string == __);
+    assert!(string == "Heello");
 
     string.remove(2);
-    assert!(string == __);
+    assert!(string == "Hello");
 }
diff --git a/src/koans/struct.rs b/src/koans/struct.rs
index abaf6c7..f49f94b 100644
--- a/src/koans/struct.rs
+++ b/src/koans/struct.rs
@@ -12,8 +12,8 @@ fn our_first_struct() {
         age: 57,
     };
 
-    assert_eq!(jim.name, __);
-    assert_eq!(jim.age, __);
+    assert_eq!(jim.name, "Jim");
+    assert_eq!(jim.age, 57);
 }
 
 // Let's try another example
@@ -26,10 +26,10 @@ fn one_more_struct() {
 
     let movie = Movie {
         title: "Star Wars",
-        runtime: __,
+        runtime: 121,
     };
 
-    assert_eq!(movie.title, __);
+    assert_eq!(movie.title, "Star Wars");
     assert_eq!(movie.runtime, 121);
 }
 
@@ -43,7 +43,7 @@ fn mutable_structs() {
 
     let mut rust = Language { version: "1.3.0" };
 
-    __ = "1.4.0";
+    rust.version = "1.4.0";
 
     assert_eq!(rust.version, "1.4.0");
 }
@@ -61,7 +61,7 @@ fn revoking_mutability() {
 
     assert_eq!(rust.version, "1.4.0");
 
-    let rust = rust;
+    let mut rust = rust;
 
     rust.version = "1.5.0";
 
@@ -86,6 +86,6 @@ fn dot_merging() {
 
     let rich = Account { balance: 1000000.00, ..broke };
 
-    assert_eq!(rich.holder, __);
-    assert_eq!(rich.balance, __);
+    assert_eq!(rich.holder, "Morgan Stanley");
+    assert_eq!(rich.balance, 1000000.00);
 }
diff --git a/src/koans/the_truth.rs b/src/koans/the_truth.rs
index 1253452..0e1cb20 100644
--- a/src/koans/the_truth.rs
+++ b/src/koans/the_truth.rs
@@ -1,4 +1,4 @@
 #[test]
 fn the_truth() {
-    assert!(__)
+    assert!(true)
 }
diff --git a/src/koans/traits.rs b/src/koans/traits.rs
index 13d7da0..965c378 100644
--- a/src/koans/traits.rs
+++ b/src/koans/traits.rs
@@ -15,7 +15,7 @@ fn implementing_traits() {
         fn full_name(&self) -> String;
     }
 
-    impl Person {
+    impl HasName for Person {
         fn full_name(&self) -> String {
             format!("{} {}", self.first_name, self.last_name)
         }
@@ -57,6 +57,10 @@ fn implementing_traits2() {
             self.level += 1;
             self.level
         }
+
+        fn print_level(&self) {
+            // stuff
+        }
     }
 
     let mut durz = Character {
@@ -77,6 +81,16 @@ fn creating_traits() {
     let num_one: u16 = 3;
     let num_two: u16 = 4;
 
+    trait IsEvenOrOdd {
+        fn is_even(&self) -> bool;
+    }
+
+    impl IsEvenOrOdd for u16 {
+        fn is_even(&self) -> bool {
+            return self % 2 == 0;
+        }
+    }
+
     fn asserts<T: IsEvenOrOdd>(x: T, y: T) {
         assert!(!x.is_even());
         assert!(y.is_even());
@@ -94,7 +108,7 @@ fn trait_constraints_on_structs() {
         latest_version: T,
     }
 
-    impl<__> Language<T> {
+    impl<T: Ord> Language<T> {
         fn is_stable(&self) -> bool {
             self.latest_version >= self.stable_version
         }
@@ -125,7 +139,7 @@ fn where_clause() {
         }
     }
 
-    fn asserts<T>(x: T, y: T) {
+    fn asserts<T>(x: T, y: T) where T: IsEvenOrOdd {
         assert!(!x.is_even());
         assert!(y.is_even());
     }
@@ -143,7 +157,7 @@ fn default_functions() {
     trait IsEvenOrOdd {
         fn is_even(&self) -> bool;
         fn is_odd(&self) -> bool {
-            __
+            return !self.is_even();
         }
     }
 
@@ -176,7 +190,7 @@ fn inheritance() {
 
     impl<T: PartialOrd> PartialOrd for Bawks<T> {
         fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-            __
+            return self.thingy.partial_cmp(&other.thingy);
         }
     }
 
diff --git a/src/koans/vec.rs b/src/koans/vec.rs
index 4587c64..a669159 100644
--- a/src/koans/vec.rs
+++ b/src/koans/vec.rs
@@ -1,14 +1,14 @@
 // Vecs act sort of like arrays, but allow more flexibility
 #[test]
 fn making_an_empty_vec() {
-    let vector: Vec<()> = __;
+    let vector: Vec<()> = Vec::new();
     assert!(vector.len() == 0);
 }
 
 // The vec! macro makes it easier to instantiate a vec
 #[test]
 fn vec_macro() {
-    let vector = __;
+    let vector = vec!(1, 2, 3, 4);
     assert!(vector.len() == 4);
 }
 
@@ -16,7 +16,7 @@ fn vec_macro() {
 #[test]
 fn adding_to_vecs() {
     let mut vector = vec![0, 1, 2];
-    vector.__(3);
+    vector.push(3);
     assert!(vector.len() == 4);
 }
 
@@ -24,7 +24,7 @@ fn adding_to_vecs() {
 #[test]
 fn removing_from_end_of_vecs() {
     let mut vector = vec![0, 1, 2, 3];
-    vector.__();
+    vector.pop();
     assert!(vector.len() == 3);
 }
 
@@ -32,7 +32,7 @@ fn removing_from_end_of_vecs() {
 #[test]
 fn storing_vec_elements() {
     let mut vector = vec![0, 1, 2, 3];
-    let num = vector.__();
+    let num = vector.pop().unwrap();
     assert!(num == 3);
 }
 
@@ -41,9 +41,9 @@ fn storing_vec_elements() {
 #[test]
 fn changing_size_of_vecs() {
     let mut vector = vec![1, 2, 3];
-    __;
+    vector.push(0);
     assert!(vector.len() == 4);
-    __;
+    vector.pop();
     assert!(vector.len() == 3);
 }
 
@@ -53,10 +53,10 @@ fn changing_size_of_vecs() {
 fn capacity() {
     let mut vector = vec![1, 2, 3, 4];
     assert_eq!(vector.capacity(), 4);
-    vector.__;
+    vector.push(0);
     assert_eq!(vector.capacity(), 8);
     vector.pop();
-    assert_eq!(vector.capacity(), __);
+    assert_eq!(vector.capacity(), 8);
 }
 
 // This extra memory can also be deallocated when its no longer needed
@@ -65,16 +65,16 @@ fn shrink_vecs() {
     let mut vector = vec![1, 2, 3, 4, 5];
     assert_eq!(vector.capacity(), 5);
     vector.pop();
-    assert_eq!(vector.capacity(), __);
+    assert_eq!(vector.capacity(), 5);
     vector.shrink_to_fit();
-    assert_eq!(vector.capacity(), __);
+    assert_eq!(vector.capacity(), 4);
 }
 
 // Vecs can reserve more space in order to prevent allocating several times
 #[test]
 fn reserve() {
     let mut vector = vec![1];
-    vector.reserve(__);
+    vector.reserve_exact(7);
     assert_eq!(vector.capacity(), 8);
 }
 
@@ -82,7 +82,7 @@ fn reserve() {
 #[test]
 fn truncate() {
     let mut vector = vec![1, 2, 3, 4, 5];
-    vector.__;
+    vector.truncate(2);
     assert_eq!(vector, vec![1, 2]);
 }
 
@@ -91,14 +91,14 @@ fn truncate() {
 fn insert() {
     let mut vector = vec![1, 2, 3, 4, 5];
     vector.insert(2, 6);
-    assert_eq!(vector, __);
+    assert_eq!(vector, vec!(1, 2, 6, 3, 4, 5));
 }
 
 // Elements can also be deleted a particular position in a Vector
 #[test]
 fn remove() {
     let mut vector = vec![1, 2, 3, 4, 5];
-    vector.remove(__);
+    vector.remove(0);
     assert_eq!(vector, vec![2, 3, 4, 5])
 }
 
@@ -108,6 +108,7 @@ fn remove() {
 fn empty_vecs() {
     let mut vector = vec![""; 0];
     assert!(vector.is_empty()); // should return true
+    vector.push("");
     assert!(!vector.is_empty()); // should return false
 }
 
@@ -116,43 +117,43 @@ fn empty_vecs() {
 #[test]
 fn vec_indices() {
     let vector = vec!["red", "green", "refactor"];
-    assert_eq!(Some(&"green"), vector.get(__));
+    assert_eq!(Some(&"green"), vector.get(1));
 }
 
 // You can also easily grab a Vec's first and last elements using the respective method
 #[test]
 fn first_and_last() {
     let vector = vec![false, true];
-    assert_eq!(vector.__, Some(&false));
-    assert_eq!(vector.__, Some(&true));
+    assert_eq!(vector.first(), Some(&false));
+    assert_eq!(vector.last(), Some(&true));
 }
 
 // It's also easy to check if a Vec contains a particular value
 #[test]
 fn contains_element() {
     let vector = vec!["Google", "Twitter", "Mozilla"];
-    assert!(vector.contains(__));
-    assert!(!vector.contains(__));
+    assert!(vector.contains(&"Google"));
+    assert!(!vector.contains(&"Microsoft"));
 }
 
 // Similar to contains(), you can also check if a Vec begins with a particular element
 #[test]
 fn starts_with() {
     let vector = vec![0, 2, 4, 6];
-    assert!(vector.starts_with(&[__]));
+    assert!(vector.starts_with(&[0]));
 }
 
 // starts_with() can also accept multiple elements
 #[test]
 fn starts_with_2() {
     let vector = vec![0, 2, 4, 6];
-    assert!(vector.starts_with(__));
+    assert!(vector.starts_with(&[0, 2, 4]));
 }
 
 // The same can be said for ends_with
 #[test]
 fn ends_with() {
-    let vector = __;
+    let vector = vec!(0, 2, 4, 6);
     assert!(vector.ends_with(&[6]));
     assert!(vector.ends_with(&[2, 4, 6]));
 }
@@ -161,6 +162,7 @@ fn ends_with() {
 #[test]
 fn reverse_vecs() {
     let mut vector = vec![1, 2, 3];
+    vector.reverse();
     assert_eq!(vector.first(), Some(&3));
 }
 
@@ -168,6 +170,7 @@ fn reverse_vecs() {
 #[test]
 fn trading_spaces() {
     let mut vector = vec![false, true];
+    vector.swap(0, 1);
     assert_eq!(vector.first(), Some(&true));
 }
 
@@ -176,7 +179,7 @@ fn trading_spaces() {
 fn chunking() {
     let vector = vec![1, 2, 1, 2];
     for chunk in vector.chunks(2) {
-        assert_eq!(chunk, &[__, __]);
+        assert_eq!(chunk, &[1, 2]);
     }
 }
 
@@ -184,9 +187,9 @@ fn chunking() {
 #[test]
 fn splitting() {
     let vector = vec!["Ruby", "Rust", "Python", "C++"];
-    let (langs1, langs2) = vector.split_at(__);
+    let (langs1, langs2) = vector.split_at(2);
     assert_eq!(langs1, &["Ruby", "Rust"]);
-    assert_eq!(langs2, &[__, __]);
+    assert_eq!(langs2, &["Python", "C++"]);
 }
 
 // Or if you don't know the specific index, you can supply a conditon at which to split
@@ -194,7 +197,7 @@ fn splitting() {
 #[test]
 fn more_splitting() {
     let vector = vec![1, 3, 4, 7, 9];
-    for num in vector.split(|x| __) {
+    for num in vector.split(|x| *x == 4) {
         assert!(!num.contains(&4));
     }
 }
-- 
2.17.0.windows.1

